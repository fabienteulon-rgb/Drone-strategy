<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#121212">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Drone Strike Ops - 100 Levels</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Courier New', Courier, monospace; touch-action: none; user-select: none; -webkit-user-select: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
        #ui-layer::after { content: " "; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.05) 50%); background-size: 100% 3px; pointer-events: none; }

        .hud-top { position: absolute; top: 15px; left: 15px; right: 15px; display: flex; justify-content: space-between; color: #00ffcc; text-shadow: 0 0 10px #00ffcc; font-weight: bold; font-size: 12px; pointer-events: none; }
        .hud-box { background: rgba(0, 20, 10, 0.8); padding: 8px 12px; border: 1px solid #00ffcc; border-radius: 2px; }
        
        .controls-area { position: absolute; bottom: 30px; width: 100%; display: flex; justify-content: space-between; align-items: flex-end; padding: 0 20px; box-sizing: border-box; pointer-events: none; }
        #joystick-zone { width: 120px; height: 120px; position: relative; pointer-events: auto; }
        .joystick-base { width: 100%; height: 100%; background: rgba(0, 255, 204, 0.05); border: 2px solid rgba(0,255,204,0.3); border-radius: 50%; position: absolute; }
        .joystick-stick { width: 50px; height: 50px; background: #fff; border-radius: 50%; position: absolute; top: 35px; left: 35px; box-shadow: 0 0 15px #fff; pointer-events: none; }

        #action-zone { pointer-events: auto; display: flex; flex-direction: column; gap: 15px; align-items: center; }
        .btn-action { width: 65px; height: 65px; border-radius: 50%; border: 2px solid #fff; background: rgba(255, 255, 255, 0.1); color: #fff; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 10px; cursor: pointer; }
        .btn-fire { width: 95px; height: 95px; border-color: #ff3300; color: #ff3300; background: rgba(255, 51, 0, 0.2); box-shadow: 0 0 20px rgba(255, 51, 0, 0.4); font-size: 18px; font-weight: 900; }

        #view-zone { position: absolute; top: 15%; left: 15%; width: 70%; height: 55%; pointer-events: auto; z-index: 1; }

        #msg-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 20; pointer-events: auto; }
        .msg-content { border: 2px solid #00ffcc; padding: 30px; background: #0a0a0a; color: #00ffcc; text-align: center; max-width: 80%; }
        .restart-btn { margin-top: 20px; padding: 15px 30px; background: #00ffcc; border: none; font-weight: bold; color: black; cursor: pointer; text-transform: uppercase; }
    </style>
</head>
<body>

    <div id="view-zone"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="hud-box">LVL: <span id="level-val">1</span></div>
            <div class="hud-box">ALT: <span id="alt-val">6.0</span>m</div>
            <div class="hud-box">OBJ: <span id="targets">0</span></div>
        </div>
        
        <div class="controls-area">
            <div id="joystick-zone">
                <div class="joystick-base"></div>
                <div class="joystick-stick" id="stick"></div>
            </div>
            <div id="action-zone">
                <div class="btn-action" id="btn-up">MONTER</div>
                <div class="btn-action btn-fire" id="btn-fire">FEU</div>
                <div class="btn-action" id="btn-down">BAISSER</div>
            </div>
        </div>
    </div>

    <div id="msg-overlay">
        <div class="msg-content">
            <h1 id="msg-title">NIVEAU RÉUSSI</h1>
            <p id="msg-desc">Préparation de la zone suivante...</p>
            <button id="next-btn" class="restart-btn">NIVEAU SUIVANT</button>
        </div>
    </div>

    <script>
        const TextureGenerator = {
            ground: () => {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = 512;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#1a2414';
                ctx.fillRect(0,0,512,512);
                for(let i=0; i<400; i++) {
                    ctx.fillStyle = ['#2d3b24', '#3d3423', '#1d2b14'][Math.floor(Math.random()*3)];
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath(); ctx.arc(Math.random()*512, Math.random()*512, Math.random()*60+10, 0, Math.PI*2); ctx.fill();
                }
                const tex = new THREE.CanvasTexture(canvas);
                tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
                tex.repeat.set(15, 15);
                return tex;
            },
            buildingSide: () => {
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#222'; ctx.fillRect(0,0,128,256);
                for(let y=20; y<240; y+=30) {
                    for(let x=15; x<110; x+=25) {
                        ctx.fillStyle = Math.random() > 0.8 ? '#ffcc00' : '#111';
                        ctx.fillRect(x, y, 12, 18);
                    }
                }
                return new THREE.CanvasTexture(canvas);
            },
            buildingTop: () => {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#333'; ctx.fillRect(0,0,128,128);
                ctx.strokeStyle = '#444'; ctx.lineWidth = 4;
                ctx.strokeRect(10,10,108,108); // Bordure de toit
                ctx.fillStyle = '#222'; ctx.fillRect(40,40,48,48); // Accès technique
                return new THREE.CanvasTexture(canvas);
            }
        };

        let currentLevel = 1;
        const SETTINGS = { speed: 0.18, inertia: 0.88, camSmooth: 0.06 };
        let gameState = { 
            active: true, targetsLeft: 0, velocity: { x: 0, z: 0 }, input: { x: 0, y: 0 }, 
            altitude: 6.0, camAngle: Math.PI / 4, camTargetAngle: Math.PI / 4 
        };

        let scene, camera, renderer, drone, reticle, targets = [], buildings = [], rotors = [], bombs = [];
        const keys = { w: false, s: false, a: false, d: false, shift: false, ctrl: false };

        function setupLevel(lvl) {
            // Nettoyage
            if(scene) {
                while(scene.children.length > 0) scene.remove(scene.children[0]);
                targets = []; buildings = []; rotors = []; bombs = [];
            } else {
                scene = new THREE.Scene();
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                document.body.appendChild(renderer.domElement);
            }

            gameState.active = true;
            gameState.targetsLeft = 4 + (lvl * 2);
            document.getElementById('level-val').innerText = lvl;
            document.getElementById('targets').innerText = gameState.targetsLeft;
            document.getElementById('msg-overlay').style.display = 'none';

            scene.background = new THREE.Color(0x0a0f12);
            scene.fog = new THREE.Fog(0x0a0f12, 40, 120);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const sun = new THREE.DirectionalLight(0xffffff, 0.7);
            sun.position.set(20, 50, 10);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            scene.add(sun);

            // Sol
            const floorRange = 50 + (lvl * 10);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(floorRange * 2, floorRange * 2), new THREE.MeshStandardMaterial({ map: TextureGenerator.ground() }));
            floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true; scene.add(floor);

            // Bâtiments (Toit propre)
            const buildingCount = 5 + (lvl * 3);
            const sideTex = TextureGenerator.buildingSide();
            const topTex = TextureGenerator.buildingTop();
            
            for(let i=0; i<buildingCount; i++) {
                const w = 4 + Math.random()*4, h = 6 + Math.random()*12, d = 4 + Math.random()*4;
                const materials = [
                    new THREE.MeshStandardMaterial({ map: sideTex }), // right
                    new THREE.MeshStandardMaterial({ map: sideTex }), // left
                    new THREE.MeshStandardMaterial({ map: topTex }),  // top (SANS FENETRE)
                    new THREE.MeshStandardMaterial({ color: 0x111 }), // bottom
                    new THREE.MeshStandardMaterial({ map: sideTex }), // front
                    new THREE.MeshStandardMaterial({ map: sideTex })  // back
                ];
                const b = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), materials);
                
                const range = 20 + (lvl * 5);
                let px = (Math.random()-0.5) * range * 2;
                let pz = (Math.random()-0.5) * range * 2;
                if(Math.abs(px) < 8 && Math.abs(pz) < 8) px += 15; // Dégager le spawn

                b.position.set(px, h/2, pz);
                b.castShadow = b.receiveShadow = true;
                scene.add(b);
                buildings.push({minX: px-w/2, maxX: px+w/2, minZ: pz-d/2, maxZ: pz+d/2, topY: h});
            }

            // Drone
            drone = createDrone();
            drone.position.set(0, gameState.altitude, 0);
            scene.add(drone);

            reticle = new THREE.Mesh(new THREE.RingGeometry(0.4, 0.5, 32), new THREE.MeshBasicMaterial({ color: 0xff3300, transparent: true, opacity: 0.8 }));
            reticle.rotation.x = -Math.PI / 2;
            scene.add(reticle);

            // Cibles
            const soldierGeo = new THREE.CylinderGeometry(0.3, 0.35, 0.9, 8);
            const soldierMat = new THREE.MeshStandardMaterial({ color: 0xff3333 });
            for(let i=0; i<gameState.targetsLeft; i++) {
                const s = new THREE.Mesh(soldierGeo, soldierMat);
                s.position.set((Math.random()-0.5)*floorRange, 0.45, (Math.random()-0.5)*floorRange);
                s.userData = { speed: 0.04 + (lvl*0.005), dir: Math.random()*Math.PI*2 };
                s.castShadow = true; scene.add(s); targets.push(s);
            }
        }

        function createDrone() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.2, 0.8), new THREE.MeshStandardMaterial({ color: 0xeeeeee }));
            group.add(body);
            const rotorMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.6 });
            const pos = [[0.65, 0.45], [0.65, -0.45], [-0.65, 0.45], [-0.65, -0.45]];
            pos.forEach((p, i) => {
                const r = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.45, 0.01, 16), rotorMat);
                r.position.set(p[0], 0.1, p[1]); group.add(r); rotors.push(r);
                const led = new THREE.PointLight(i<2?0xff0000:0x00ff00, 1.5, 3);
                led.position.set(p[0], -0.1, p[1]); group.add(led);
            });
            return group;
        }

        function fire() {
            if(!gameState.active) return;
            const b = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), new THREE.MeshBasicMaterial({color: 0xffaa00}));
            b.position.copy(drone.position);
            scene.add(b);
            bombs.push({mesh: b, vy: 0});
        }

        // Logic loop
        function animate() {
            requestAnimationFrame(animate);
            if(!gameState.active) return;

            // Inputs
            let mx = gameState.input.x; let my = gameState.input.y;
            if(keys.a) mx = -1; if(keys.d) mx = 1;
            if(keys.w) my = -1; if(keys.s) my = 1;
            
            gameState.altitude = THREE.MathUtils.clamp(gameState.altitude + (keys.shift ? 0.08 : (keys.ctrl ? -0.08 : 0)), 2, 40);
            drone.position.y = gameState.altitude;
            document.getElementById('alt-val').innerText = gameState.altitude.toFixed(1);

            const cos = Math.cos(gameState.camAngle); const sin = Math.sin(gameState.camAngle);
            const rx = mx * cos - my * sin; const rz = mx * sin + my * cos;

            gameState.velocity.x = (gameState.velocity.x + rx * SETTINGS.speed * 0.1) * SETTINGS.inertia;
            gameState.velocity.z = (gameState.velocity.z + rz * SETTINGS.speed * 0.1) * SETTINGS.inertia;
            drone.position.x += gameState.velocity.x;
            drone.position.z += gameState.velocity.z;

            // Collisions batiments
            buildings.forEach(b => {
                if (drone.position.x > b.minX-0.6 && drone.position.x < b.maxX+0.6 &&
                    drone.position.z > b.minZ-0.6 && drone.position.z < b.maxZ+0.6 &&
                    drone.position.y < b.topY + 0.2) {
                    gameOver("DRONE DÉTRUIT", "Collision avec un obstacle", "#ff3300", false);
                }
            });

            rotors.forEach(r => r.rotation.y += 0.6);
            drone.rotation.z = -gameState.velocity.x * 1.2;
            drone.rotation.x = gameState.velocity.z * 1.2;
            drone.rotation.y = THREE.MathUtils.lerp(drone.rotation.y, -gameState.camAngle + Math.PI/4, 0.1);

            reticle.position.set(drone.position.x, 0.1, drone.position.z);

            // Camera
            gameState.camAngle = THREE.MathUtils.lerp(gameState.camAngle, gameState.camTargetAngle, 0.1);
            const camDist = 16 + (gameState.altitude * 0.5);
            camera.position.lerp(new THREE.Vector3(
                drone.position.x + Math.cos(gameState.camAngle) * camDist,
                gameState.altitude + 15,
                drone.position.z + Math.sin(gameState.camAngle) * camDist
            ), SETTINGS.camSmooth);
            camera.lookAt(drone.position.x, 0, drone.position.z);

            // Bombs
            for(let i=bombs.length-1; i>=0; i--) {
                bombs[i].vy -= 0.025; bombs[i].mesh.position.y += bombs[i].vy;
                if(bombs[i].mesh.position.y <= 0) {
                    const p = bombs[i].mesh.position;
                    targets.forEach((t, idx) => {
                        if(t.position.distanceTo(p) < 3.5) {
                            scene.remove(t); targets.splice(idx, 1);
                            gameState.targetsLeft--; document.getElementById('targets').innerText = gameState.targetsLeft;
                        }
                    });
                    scene.remove(bombs[i].mesh); bombs.splice(i, 1);
                    if(gameState.targetsLeft === 0) gameOver("NIVEAU RÉUSSI", "Zone suivante débloquée", "#00ffcc", true);
                }
            }

            targets.forEach(t => {
                t.position.x += Math.cos(t.userData.dir) * t.userData.speed;
                t.position.z += Math.sin(t.userData.dir) * t.userData.speed;
                if(Math.abs(t.position.x) > 100 || Math.abs(t.position.z) > 100) t.userData.dir += Math.PI;
            });

            renderer.render(scene, camera);
        }

        function gameOver(title, desc, color, success) {
            gameState.active = false;
            document.getElementById('msg-overlay').style.display = 'flex';
            document.getElementById('msg-title').innerText = title;
            document.getElementById('msg-title').style.color = color;
            document.getElementById('msg-desc').innerText = desc;
            const btn = document.getElementById('next-btn');
            if(success) {
                btn.innerText = "NIVEAU SUIVANT";
                btn.onclick = () => { currentLevel++; setupLevel(currentLevel); };
            } else {
                btn.innerText = "RÉESSAYER";
                btn.onclick = () => setupLevel(currentLevel);
            }
        }

        // Init Inputs
        function initInputs() {
            const stick = document.getElementById('stick');
            const joyZone = document.getElementById('joystick-zone');
            let joyActive = false, joyStart = {x:0, y:0};

            const startJoy = (x, y) => { joyActive = true; const rect = joyZone.getBoundingClientRect(); joyStart = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 }; };
            const moveJoy = (x, y) => {
                if(!joyActive) return;
                const dx = x - joyStart.x, dy = y - joyStart.y;
                const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 45);
                const ang = Math.atan2(dy, dx);
                stick.style.transform = `translate(${Math.cos(ang)*dist}px, ${Math.sin(ang)*dist}px)`;
                gameState.input.x = (Math.cos(ang)*dist)/45;
                gameState.input.y = (Math.sin(ang)*dist)/45;
            };

            const viewZone = document.getElementById('view-zone');
            let viewActive = false, viewLastX = 0;
            const startView = (x) => { viewActive = true; viewLastX = x; };
            const moveView = (x) => { if(viewActive) { gameState.camTargetAngle -= (x - viewLastX) * 0.005; viewLastX = x; } };

            joyZone.addEventListener('mousedown', e => startJoy(e.clientX, e.clientY));
            joyZone.addEventListener('touchstart', e => { e.preventDefault(); startJoy(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
            viewZone.addEventListener('mousedown', e => startView(e.clientX));
            viewZone.addEventListener('touchstart', e => startView(e.touches[0].clientX));

            window.addEventListener('mousemove', e => { moveJoy(e.clientX, e.clientY); moveView(e.clientX); });
            window.addEventListener('touchmove', e => {
                for(let t of e.touches) {
                    if(joyActive && t.target.closest('#joystick-zone')) moveJoy(t.clientX, t.clientY);
                    if(viewActive && t.target.closest('#view-zone')) moveView(t.clientX);
                }
            }, {passive:false});

            window.addEventListener('mouseup', () => { joyActive = viewActive = false; stick.style.transform = "translate(0,0)"; gameState.input = {x:0, y:0}; });
            window.addEventListener('touchend', () => { joyActive = viewActive = false; stick.style.transform = "translate(0,0)"; gameState.input = {x:0, y:0}; });

            document.getElementById('btn-fire').addEventListener('mousedown', fire);
            document.getElementById('btn-fire').addEventListener('touchstart', e => { e.preventDefault(); fire(); }, {passive:false});

            let altIn = 0;
            const btnU = document.getElementById('btn-up'), btnD = document.getElementById('btn-down');
            btnU.onmousedown = btnU.ontouchstart = (e) => { e.preventDefault(); keys.shift = true; };
            btnU.onmouseup = btnU.onmouseleave = btnU.ontouchend = () => keys.shift = false;
            btnD.onmousedown = btnD.ontouchstart = (e) => { e.preventDefault(); keys.ctrl = true; };
            btnD.onmouseup = btnD.onmouseleave = btnD.ontouchend = () => keys.ctrl = false;

            window.addEventListener('keydown', e => {
                const k = e.key.toLowerCase();
                if(k === 'z' || k === 'w') keys.w = true; if(k === 's') keys.s = true;
                if(k === 'q' || k === 'a') keys.a = true; if(k === 'd') keys.d = true;
                if(e.shiftKey) keys.shift = true; if(e.ctrlKey) keys.ctrl = true;
                if(k === ' ') fire();
            });
            window.addEventListener('keyup', e => {
                const k = e.key.toLowerCase();
                if(k === 'z' || k === 'w') keys.w = false; if(k === 's') keys.s = false;
                if(k === 'q' || k === 'a') keys.a = false; if(k === 'd') keys.d = false;
                if(!e.shiftKey) keys.shift = false; if(!e.ctrlKey) keys.ctrl = false;
            });
        }

        window.onload = () => {
            initInputs();
            setupLevel(1);
            animate();
        };

        window.addEventListener('resize', () => {
            if(camera) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); }
            if(renderer) renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
